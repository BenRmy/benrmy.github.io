[{"title":"python的内部机制","url":"/2019/05/03/python3 内部机制/","content":"\n理解built-in objects，新式类的元类为type类。\n\n__builtin__模块提供对Python所有内置标识符的直接访问; 例如，`__builtin__.open`是内置函数的全名 open()。了解其他包括内置函数、内置常量、内置类型。\n\n为什么需要self参数，这个特别的变量指(实例)对象本身。\n\n# `__init__()`不是构造方法\n\n对象生命周期的基础是创建、初始化和销毁，__init__方法在类的一个对象被创建时，马上运行进行初始化。而构造方法包括创建对象和初始化对象，在python当中，分为两步执行：先执行__new__方法，然后执行__init__方法。\n+ `object.__new__(cls，[，args...])`：其中cls代表类，args为参数列表。在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法。\n\n注意：__new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供；__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例。\n\n+ `object.__init__(self，[，args...])`：其中self代表实例对象，args为参数列表，当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。\n\n注意：__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值。也就是，__new__在__init__之前被调用，__new__的返回值(实例)将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。\n\n# __new__()和__init__()不同点\n\n+ `__new__()`方法一般需要返回类的对象，当返回类的对象时将会自动调用__init__()方法进行初始化，如果没有对象返回，则__init__()方法不会被调用。`__init__()`不需要显式返回，默认为None，否则会在运行时抛出TypeError。\n+ 当需要控制实例创建的时候可使用__new__()方法，而控制实例初始化的时候使用__init__()方法。\n+ 一般情况下不需要覆盖__new__()方法，但当子类继承自不可变类型，如str、int、或者tuple的时候，往往需要覆盖该方法。\n+ 当需要覆盖__new__()和__init__()方法的时候，这两个方法的参数必须保持一致，如果不一致将导致异常。\n\n# 何时覆盖__new__()\n\n+ 当类继承(str、int、tuple或者frozenset等)不可变类型且默认的__new__()方法不能满足需求的时候。\n+ 用来实现工厂模式或者单例模式或者进行元类编程(元类编程中常常需要使用__new__()来控制对象创建)的时候。\n+ 作为用来初始化__init__()方法在多继承的情况下，子类的__init__()方法如果不显式调用父类的__init__()方法，则父类的__init__()方法不会被调用。\n\n# 变量作用域\n\n1. 局部作用域：一般来说函数的每次调用都会创建一个新的本地作用域，拥有新的命名空间。因此函数内的变量名可以与函数外的其他变量相同，由于其命名空间不同，并不会产生冲突。默认情况下函数内部任意的赋值操作(包括=语句、import语句、def语句、参数传递等)所定义的变量名，如果没有用global语句，则声明都为局部变量，即仅在函数内可见。\n2. 全局作用域：定义在python模块文件中的变量名拥有全局作用域，需要注意的是，这里的全局仅限单个文件，即在一个文件的顶层的变量名仅在这个文件内可见，并非所有的文件，其他文件中想使用这些变量名必须先导入对应的模块。当在函数之外给一个变量名赋值时是在全局作用域的情况下进行的。\n3. 嵌套作用域：一般在多重函数嵌套的情况下才会考虑到。需要注意的是global语句仅针对全局变量，在嵌套作用域的情况下，如果想在嵌套的函数内修改外层函数中定义的变量，即使使用global也不能达到目的，其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量。真正的解决方案是python3的nonlocal关键字。\n4. 内置作用域：它是通过一个标准库名为__builtin__的模块来实现的。其包括内置函数、内置常量和内置类型等。\n\n# 变量查找机制\n\n+ 在最内层的范围内查找，一般而言，就是函数内部，即在locals()里面查找。\n+ 在模块内查找，即在globals()里面查找。\n+ 在外层查找，即在内置模块中查找，也就是在__builtin__中查找。\n\n# MRO(方法解析顺序)与多继承，新式类广度C3 MRO算法\n\n事实上，对于定义的每一个类，Python 会计算出一个方法解析顺序(Method Resolution Order，MRO)列表，它代表了类继承的顺序。多重继承会引发很多问题，比如二义性，Python中一切皆引用，这使得他不会像C++一样使用虚基类处理基类对象重复的问题，但是如果父类存在同名函数的时候还是会产生二义性，Python中处理这种问题的方法就是MRO。\n\n## Python2.2以前的版本：经典类(classic class)时代。\n\n经典类是一种没有继承的类，实例类型都是type类型，如果经典类被作为父类，子类调用父类的构造函数时会出错。这时MRO的方法为DFS(深度优先搜索(子节点顺序：从左到右))。\n\n## Python2.2版本：新式类(new-style class)诞生。\n\n为了使类和内置类型更加统一，引入了新式类。新式类的每个类都继承于一个基类，可以是自定义类或者其它类，默认承于object。子类可以调用父类的构造函数。这时有两种MRO的方法，如果是经典类MRO为DFS(深度优先搜索(子节点顺序：从左到右))；如果是新式类MRO为BFS(广度优先搜索(子节点顺序：从左到右))。\n\n又分为正常继承模式和棱形继承模式。但两种继承模式在DFS和BFS中均有优缺点，所以使用了C3算法，其解决了单调性问题，和只能继承无法重写的问题。\n\n# super和父类没有实质性的关联\n\n在类的继承中，如果重定义某个方法，该方法会覆盖父类的同名方法，但有时，希望能同时实现父类的功能，这时就需要调用父类的方法，可通过使用 super 来实现。\n\nsuper 的一个最常见用法可以说是在子类中调用父类的初始化方法。但其和父类没有实质性的关联，事实上super(cls，inst) 获得的是cls在inst的 MRO 列表中的下一个类，只是有时其下一个类刚好是其父类。\n\nsuper的工作原理如下：\n```python\ndef super(cls，inst):\n    mro = inst.__class__.mro()\n    return mro[mro.index(cls) + 1]\n```\n\n一个类的MRO列表就是合并所有父类的MRO列表，并遵循以下三条原则：\n+ 子类永远在父类前面\n+ 如果有多个父类，会根据它们在列表中的顺序被检查\n+ 如果对下一个类存在的两个合法的选择，选择第一个父类\n\n# 描述符机制\n\n描述符是一种协议，实现了相应的描述符方法便会有相应的描述符行为：\n+ __get__(self，instance，owner) --> return value\n+ __set__(self，instance，value)\n+ __delete__(self，instance)\n\n描述符对象以类型 (owner class) 成员的方式出现，且最少要实现一个协议方法。最常见的描述符有 property、staticmethod、classsmethod。访问描述符类型成员时，解释器会自动调用与行为相对应的协议方法。\n+ 实现 get 和 set 方法，称为 data descriptor。\n+ 仅有 get 方法的，称为 non-data descriptor。\n+ get 对 owner_class、owner_instance 访问有效。\n+ set、delete 仅对 owner_instance 访问有效。\n\n>实例方法绑定到instance实例；类方法绑定到class类；静态方法没有绑定，仅仅是个方法。\n\n任何实现了`__get__()，__set__()，或者 __delete__()`方法的对象就是描述符。一个class的属性是一个描述符的时候，对这个属性的访问会触发特定的绑定行为。一般使用a.b的方式访问，修改和删除属性，它通过查找class的字典来访问属性b，但是如果b是一个描述符，那么get，set和delete相关的描述符方法会被调用。描述符是很多特性实现的基础，比如：方法，函数，属性，类方法，静态方法还有对父类方法的引用。\n\n# 区别__get__，__getattr__()和__getattribute__()方法\n\n`__get__，__getattr__和__getattribute`都是访问属性的方法，但不太相同。\n+ `__getattr__(self，name)`：当一般位置找不到attribute的时候，会调用getattr，返回一个值或AttributeError异常。\n+ `__getattribute__(self，name)`：无条件被调用，通过实例访问属性。如果class中定义了__getattr__()，则__getattr__()不会被调用(除非显示调用或引发AttributeError异常)\n+ `__get__(self，instance，owner)`：如果class定义了它，则这个class就可以称为descriptor。owner是所有者的类，instance是访问descriptor的实例，如果不是通过实例访问，而是通过类访问的话，instance则为None。\n\ndescriptor的实例自己访问自己是不会触发__get__的，而会触发__call__，只有descriptor作为其它类的属性时才有意义。\n\n注意，不仅仅是__getattribute__()引发的AttributeError异常，property中定义的get()方法抛出异常的时候也会调用_getattr__()方法。需要特别注意的是当这两个方法同时被定义的时候，要么在__getattribute__()中显式调用，要么触发AttributeError异常，否则__getattr__()永远不会被调用。\n\n每次通过实例访问属性，都会经过__getattribute__函数。而当属性不存在时，仍然需要访问__getattribute__，不过接着要访问__getattr__。这就好像是一个异常处理函数。而每次访问descriptor(即实现了__get__的类)，都会先经过__get__函数。需要注意的是，当使用类访问不存在的变量是，不会经过__getattr__函数。而descriptor不存在此问题，只是把instance标识为none而已。\n\n## 注意事项\n\n+ 注意无穷递归调用：覆盖__getattr__()和__getattribute__()的时候必须小心，调用父类的相应方法才不会造成无穷递归。\n+ 访问未定义的属性。如果在__getattr__()方法中不抛出AttributeError异常或者显式返回一个值，则会返回None，此时可能会影响程序的实际运行预期。\n\n## 两点提醒\n\n+ 覆盖了__getattribute__()方法之后，任何属性的访问都会调用用户定义的__getattribute__()方法，性能上有所降低，比使用默认的方法要慢。\n+ 覆盖的__getattr__()方法如果能够动态处理事先未定义的属性，可以更好地实现数据隐藏。因为dir()通常只显示正常的属性和方法，因此不会将该属性列为可用属性。\n\n# 使用更为安全的property\n\nproperty的定义为：property(fget=None，fset=None，fdel=None，doc=None)\n\n注意：使用property并不能真正地实现完全属性只读的目的，正如以双下划线命名的变量并不是真正的私有变量一样，这些方法只是在直接修改属性上增加了一些障碍。\n\n# metaclass元类\n\n类就是一组用来描述如何生成一个对象的代码段，但python类同样也是一种对象。元类就是用来创建类的“东西”。type就是Python在背后用来创建所有类的元类。str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。\n\n也可以把元类称为“类工厂”(不要和工厂类搞混了)，type就是Python的内建元类，当然了，也可以创建自己的元类。可以在写一个类的时候为其添加__metaclass__属性。\n\n首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。\n\n可以在__metaclass__中放置些什么代码呢？可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。\n\n元类的主要目的就是为了当创建类时能够自动地改变类。就元类本身而言，作用其实是很简单：\n+ 拦截类的创建\n+ 修改类\n+ 返回修改之后的类\n\nPython中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，可能不希望通过使用元类来对类做修改。也可以通过其他两种技术来修改类：\n+ Monkey patching，即猴子补丁\n+ class decorators，即类装饰器\n\n当需要动态修改类时，99%的时间里最好使用上面这两种技术。当然了，其实在99%的时间里根本就不需要动态修改类。\n\n# python对象协议\n\n存在多种协议，用于实现鸭子类型(Duck Typing)。包括类型转换协议、比较大小协议、数值类型相关、容器协议、可调用对象协议、可哈希对象、属性协议、上下文管理协议等。\n\n**类型转换协议**：顾名思义就是用来进行类型转，如整数到浮点数。\n\n**比较大小的协议**：这个协议依赖于__cmp__()方法，当两者相等时返回0，self<0时返回负值，反之返回正值。但是这种返回有点复杂，Python又定义了`__eq__()、__ne__()、__lt__()、__gt__()`等方法来实现相等、不等、小于和大于的判定。这也是Python对==，!=，<，>等操作符进行重载支撑的机制，也就是说重载这些操作符，就是要重新定义对应的方法。\n\n**数值类型相关的协议**：这一类方法比较多，主要是数值之间的一些操作。另外Python中还有一个特有的概念: 反运算。\n\n**容器类协议**：既然为容器，那么肯定会有查询、取值、删除、赋值、求长度等等一系列动作行为，那么必有对应的方法与这些操作对应。\n\n**可调用对象协议**：也就是类似函数对象，能够让类实例表现的像函数一样，这样可以让每一个函数调用都有所不同。对象通过提供`__call__(slef，[，*args [，**kwargs]])`方法可以模拟函数的行为。\n\n**哈希协议**：如果对象有__hash__()方法，表示是一个可哈希对象。如果一个对象是可哈希的，那么在它的生存期内必须不可变(需要一个哈希函数)，而且可以和其他对象比较(需要比较方法)，比较值相同的对象一定有相同的哈希值。这也就是说所有不可变的内置类型都是可哈希的，比如string，tuple。所有可变的内置类型都是不可哈希的，比如list，dict(即没有__hash__()方法)。字典的key必须是可哈希的，所以tuple，string可以做key，而list不能做key。\n\n**上下文管理协议**：即在对象中定义__enter__()和__exit__()方法。其适用于可能事先需要设置，事后做清理工作的场景。\n\n**利用操作符重载实现中缀语法**：类似于str.upper(hex(int(\"423423\"))) 这种语法形式的称之为前缀式语法，也就是说语法函数这些东西在参数的前面它执行的时候是先执行最里面的那部分，类似于一个洋葱，一层一层包裹。而中缀语法类似于pipe管道的写法。如：\n```python\nclass P(object):  \n    def __init__(self，f):  \n        self.f = f  \n    def __ror__(self，y):  \n        return self.f(y) \n\"423423\" | P(int) | P(hex) | P(str.upper)\n```\n\n**python迭代器协议**：对象必须提供一个next方法，执行该方法要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代 (只能往后走不能往前退)。协议是一种约定，可迭代对象实现了迭代器协议，python的内部工具(如for循环，sum，min，max函数等)使用迭代器协议访问对象。\n\n**可迭代对象**：只要对象本身有__iter__方法，那它就是可迭代的。\n\n注：对象可以通过__next__取值，就是迭代器。或执行对象下的__iter__方法，得到的结果就是迭代器。\n\n## 迭代器优点\n+ 迭代器提供了一种不依赖于索引的取值方式，这样就可以遍历那些没有索引的可迭代对象了(字典，集合，文件)\n+ 迭代器与列表比较，迭代器是惰性计算的，更节省内存\n\n## 迭代器缺点\n+ 无法获取迭代器的长度，使用不如列表索引取值灵活\n+ 一次性的，只能往后取值，不能倒着取值\n\n**for循环的本质**：循环所有对象，全都是使用迭代器协议(字符串，列表，元组，字典，集合，文件对象)，这些都是可迭代对象，只不过在for循环式(遍历之前)，调用了对象内部的__iter__方法将其变成了可迭代对象(迭代器)，然后for循环调用可迭代对象的__next__方法去取值，而且for循环会捕捉StopIteration异常，以终止迭代。\n\n**python的生成器**：可以理解为一种数据类型，这种数据类型自动实现了迭代器协议(其他的数据类型需要调用自己内置的__iter__方法)，所以生成器就是可迭代对象。注意：生成器只能遍历一次。\n\n生成器分类及在python中的表现形式：(Python有两种不同的方式提供生成器)\n+ 生成器函数：常规函数定义，但是，使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次从它离开的地方继续执行。生成器就是一个函数，这个函数内包含有yield这个关键字。yield把函数变成生成器，直到迭代器。\n+ 生成器表达式：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表。把列表解析的[]换成()得到的就是生成器表达式。列表解析与生成器表达式都是一种便利的编程方式，只不过生成器表达式更节省内存。\n\nPython使用生成器对延迟操作提供了支持。所谓延迟操作，是指在需要的时候才产生结果，而不是立即产生结果。这也是生成器的主要好处。生成器本质和其他的数据类型一样，都是实现了迭代器协议，只不过生成器附加了一个延迟计算省内存的好处。\n\n## 生成器函数\n+ 语法上和函数类似：生成器函数和常规函数几乎是一样的。它们都是使用def语句进行定义，差别在于，生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值。\n+ 自动实现迭代器协议：对于生成器，Python会自动实现迭代器协议，以便应用到迭代背景中(如for循环，sum函数)。由于生成器自动实现了迭代器协议，所以，可以调用它的next方法，并且，在没有值可以返回的时候，生成器自动产生StopIteration异常。\n+ 状态挂起：生成器使用yield语句返回一个值。yield语句挂起该生成器函数的状态，保留足够的信息，以便之后从它离开的地方继续执行。\ne.send与next(e)的区别：\n+ 如果函数内yield是表达式形式，那么必须先next(e)\n+ 二者的共同之处是都可以让函数在上次暂停的位置继续运行，不一样的地方在于send在触发下一次代码的执行时，会顺便给yield传一个值\n\n## yield与return区别\n+ return只能返回一次函数就彻底结束了，而yield能返回多次值\n+ 函数在暂停以及继续下一次运行时的状态是由yield保存\n\n另：如果在一个函数内部yield的使用方式是表达式形式的话，如x=yield，那么该函数成为协程函数。\n\n**基于生成器的协程及greenlet**：greenlet是一个C语言编写的程序库，它与yield没有密切的关系。greenlet这个库里最为关键的一个类型就是PyGreenlet，它是一个结构体，每一个PyGreenlet都可以看成一个调用栈，从它的入口函数开始，所有的代码都在这个调用栈上运行。它能够随时记录代码运行现场，并随时中止，以及恢复。\n\ngevent将greenlet与libevent/libev结合起来，是时下最受欢迎的网络编程库。\n\n# 全局解释器锁GIL的局限性\n\nGIL，它是python虚拟机上用作互斥线程的一种机制，它的作用是保证任何情况下虚拟机只有一个线程被运行，而其他线程都处于等待GIL锁被释放的状态。其是CPython中特有的全局解释器锁(其它实现版本因为有自己线程调度机制，所以没有GIL机制)。这把锁在解释器进程中是全局有效的，它主要锁定Python线程的CPU执行资源。CPython解释器中，线程想要执行CPU指令需要2个条件：\n+ 被操作系统调度出来(操作系统允许它占用CPU)\n+ 获取到GIL(CPython解释器允许它执行指令)\n\n非常不幸的是，并不总是能满足这2个条件。经常出现的情况是：已经满足条件1，却被条件2限制。而这就是GIL影响Python性能的主要原因(其它语言只需满足条件1即可)。\n为了能在Python中利用多核来提高计算效率，还是有如下的方法可以做到：\n+ 使用python3.4或更高版本(对GIL机制进行了优化)\n+ 使用多进程替换多线程(多进程之间没有GIL，但是进程本身的资源消耗较多)\n+ 使用C编写高性能模块(with nogil去掉GIL限制)\n+ 指定cpu运行线程(使用affinity模块)\n+ 使用Pypy、Jython、IronPython等无GIL解释器\n+ 全IO密集型任务时可以使用多线程，GIL锁对其影响不大\n+ 使用协程(高效的单线程模式，也称微线程；通常与多进程配合使用)\n\n所有线程都是轮流占用(单个)CPU执行指令。\n\n# GIL锁机制\n\n对于有I/O操作的多线程，始终只有一个活的GIL锁的线程在运行，每次遇到I/O操作便会进行GIL锁的释放；但对于纯计算的程序，没有I/O操作，解释器便会根据sys.setcheckinterval的设置来自动进行线程间的切换，默认情况下每个100个时钟(python内部时钟，对应于解释器执行的指令)就会释放GIL锁从而轮换其他线程的执行。\n\nGIL优点是大大简化了python线程中共享资源的管理，此外，对于扩展的C程序的外部调用，即使不是线程安全的，但由于GIL的存在，线程会阻塞直到外部调用函数返回，线程安全不再是一个问题。缺点是会对多线程的效率有不小影响(尤其是CPU计算密集型)。\n\n# GIL对多线程和多进程的影响\n\n+ Python的GIL在单核情况下对性能的影响可以忽略不计，几乎没有。\n+ Python由于其GIL的存在在多核CPU的情况下Thread的表现非常差，但是Process则不受GIL的影响。\n+ Python内置的数据类是不适合用于大量的数学计算的，当然这也不仅仅是Python的问题，其它完全面向对象的语言都有这个问题，要进行大量的数学计算就要用把代码移到C/C++中去实现，这样不仅可以去除GIL的影响，更可以让性能获得几十倍上百倍的提升，或者用numpy之类的扩展在执行科学计算时也可以让性能大幅的提升。\n+ Python慢其实就是慢在数字计算上，如果每一个数字都是一个对象，在计算的时候就免不了不断的为对象申请内存，释放内存，速度肯定就慢下来。\n+ Python对数据结构的操作是非常高效的，像Python内置的强大的dict，str，list等，其处理的速度真的可以和C媲美，因为它们的实现本身就是用C实现的。而`数据结构+算法=程序`只有在用Python这样的语言时才会有更切身的体会。\n+ 用Python开发程序时，不得不花点时间在性能优化上来，过程也很简单：用cProfile(性能分析器)之类的工具查找出比较耗时的操作，然后将其移到C中去实现。另外，如果是使用多核CPU的情况，一定要小心使用Thread，尽量用Process来替代Thread。Python的性能优化过程也是程序开发中有挑战又非常有成就感的部分。\n+ 记住，不要过早的对程序进行优化，过早优化是罪恶之源 -- Donald Knuth。\n\n# 对象的管理与垃圾回收(GC模块)\n\nPython中的垃圾回收是以引用计数为主，标记-清除和分代收集为辅。引用计数最大缺陷就是循环引用的问题，所以Python采用了辅助方法。\n\n注意：__del__方法要慎用，如果用的话一定要保证没有循环引用。否则可能会造成内存泄漏。\n","tags":["python"]},{"title":"一些库的使用建议","url":"/2019/04/23/python3 一些建议/","content":"\n# 按需选择sort()或者sorted()\n\n## 1.相比sort()，sorted()使用的范围更广，两者的函数形式分别如下：\n+ `sorted(iterable cmp[，key][，reverse])`\n+ `s.sort(iterable cmp[，key][，reverse])`\n\n不过在python3中取消掉了cmp参数。取而代之的是functools下面的cmp_to_key()函数。\n+ cmp为用户定义的任何比较函数，函数的参数为两个可比较的元素(来自iterable或者list)，函数根据第一个参数与第二个参数的关系依次返回-1、0或者+1(第一个参数小于第二个参数则返回负数)。默认为None。\n+ key是一个带参数的函数，用来为每个元素提取比较值，默认为None(即直接比较每个元素)。\n+ reverse表示排序结果是否反转。\n\n## 2. sort()会修改原来的列表，而sorted()重新生成一个列表。\n\nsort()函数不需要复制原有列表，消耗的内存较少，效率也较高。\n\n## 3. 无论是sort()还是sorted()函数，传入参数key比传入参数cmp的效率要高。\n\ncmp传入的函数在整个排序过程中会调用多次，函数开销较大；而key针对每个元素仅作一次处理。\n\n## 4. sorted()函数的功能十分强大，使用它可以方便地针对不同的数据结构进行排序。\n\n排序示例：\n```python\npersons = [{'name': 'Jon'，'age': 32}，\n               {'name': 'Alan'，'age': 50}，\n               {'name': 'Bob'，'age': 23}]\npersons.sort(key=lambda x: (x['name']))\nfrom operator import itemgetter\n# sorted\n# 字典排序\nphonebook = {'Linda': '7750'，'Bob': '9345'，'Carol': '5834'}\nprint(sorted(phonebook.items()，key=itemgetter(1)))\n# 多维list排序\ng = [['Bob'，95，'A']，['Alan'，86，'C']，['Mandy'，82，'A']，['Rob'，86，'E']]\nprint(sorted(g，key=itemgetter(2，1)))\n# 字典中混合list排序\n# 如果字典中的key或者值为列表，需要对列表中的某一个位置的元素排序也是可以做到的。\nd = {'Li': ['M'，7]，'Zhang': ['E'，2]，'Wang': ['P'，3]，'Du': ['C'，2]，\n     'Ma': ['C'，9]，'Zhe': ['H'，7]}\nprint(sorted(d.items()，key=lambda k: itemgetter(1)(k[1])))\n# list中混合字典排序\n# 列表中的每一个元素为字典形式，可以针对字典的多个key值进行排序也可。\ng2 = [{'name': 'Bob'，'wins': 10，'losses': 3，'rating': 75.00}，\n      {'name': 'David'，'wins': 3，'losses': 5，'rating': 57.00}，\n      {'name': 'Carol'，'wins': 4，'losses': 5，'rating': 57.00}，\n      {'name': 'Patty'，'wins': 9，'losses': 3，'rating': 71.48}，]\nprint(sorted(g2，key=itemgetter('rating'，'name')))\n```\n\n# 使用copy模块深拷贝对象\n\n+ 浅拷贝：构造一个新的复合对象并将原对象中发现的引用插入该对象中，浅拷贝的实现方式有多种，如工厂函数、切片操作、copy模块中的copy操作等。\n+ 深拷贝：也构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续执行拷贝，因此产生的对象不受其他引用对象操作的影响。\n\n# 比较\n\n+ 赋值是将一个对象的地址赋值给一个变量，让变量指向该地址( 旧瓶装旧酒 )。\n+ 浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素( 新瓶装旧酒 )。\n+ 深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说( 新瓶装新酒 )。\n\n# 使用Counter进行计数统计\n\nCounter类属于字典类的子类，是一个容器对象，主要用来统计散列对象，支持集合操作+、-、&和|，其中&和|操作分别返回两个Counter对象各个元素的最小值和最大值，它提供了三种不同的方式来初始化：\n+ Counter('success')    # 可迭代对象\n+ Counter(s=3，c=2，e=1，u=1)    # 关键字参数\n+ Counter({'s': 3，'c': 2，'e': 1，'u': 1})    # 字典\n\n**ConfigParser库**：对配置文件进行解析。\n\n**使用argparse处理命令行参数**：标准库还有getopt、optparse，argparse也是。\n\n**使用pandas处理大型csv文件**：pandas是一个很强悍的数据分析计算模块。\n\n\n一般情况使用ElementTree解析XML，xml.dom.minidom和xml.sax是python中处理xml文件很出名的模块，但是它们很不相同：\n+ DOM需要将整个XML文件加载到内存中并解析为一棵树，虽然使用简单，但是占用内存较多，性能方面不占优势。\n+ SAX是基于事件驱动的，虽不需要全部装入XML文件，但其处理过程却较为复杂。cElementTree是C版本实现，优先选择。其内存上消耗明显低于DOM解析。由于它的底层进行了一定的优化，并且它的iterparse解析工具支持SAX事件驱动，能够以迭代的形式返回XML部分数据结构，从而避免将整个XML文件加载到内存中。同时，它也支持XPath查询，非常方便。\n\n在处理XML文件大小在GB或近似GB级别的时候，第三方的lxml是个更好的选择。\n\n**理解pickle优劣（Python对象持久化）**：它也有C版本实现，优先选择。序列化的另一个不错的选择--JSON。\n\n**使用traceback**：获取栈信息。\n\n**使用logging**：记录日志信息。\n\n**使用threading模块**：编写多线程程序。\n\n**使用Queue**：使多线程编程更安全。\n","tags":["python"]},{"title":"python3的一些使用点","url":"/2019/04/16/python3 进阶点/","content":"\n# 基础知识\n\n+ 字符串推荐使用format占位匹配，进行格式化字符串。\n+ reversed：序列(列表，元组，字符串，不改变原对象)反转，(另一种方式：`aa[::-1]`)：使用reversed时是返回一个迭代器，当第一次使用时会消耗该迭代器，以致留下空序列，所以无法再次使用该迭代器进行迭代操作(相当于生成器)。\n+ for循环迭代(迭代：iteration、可迭代的：Iterable、迭代器：iterator)：迭代相比较迭代器更加抽象，用到for...in...的操作，称之为迭代，而这种能遍历的行为或者能迭代的行为称之为可迭代的，而迭代器是具体到迭代行为的操作者或者说是实行者，在Python中有个iter() 函数专门返回的就是迭代器对象，而这个对象可以通过next的属性对可迭代对象进行遍历，称这种对象为迭代器。python的for循环抽象程序要高于java 的for循环，因为python的for循环不仅可以用在list和tuple上，还可以作用在其他可迭代的对象上(比如没有下标的 dict)。同时支持for N1，N2，N3... in list:，即可迭代对象中还有可迭代对象(数目相同)。使用dir()函数查看对象的属性列表，如果只有__iter__()函数则是可迭代的，如果__iter__()和__next__()函数都有则是迭代器；或者使用isinstance() 函数来判断一个对象是否是一个已知的迭代类型。\n+ with语句及其打开文件：with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的清理操作，释放资源。\n\n## 上下文管理协议(Context Management Protocol)\n\n包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。\n\n## 上下文管理器(Context Manager)\n\n支持上下文管理协议的对象，这种对象实现了`__enter__() 和 __exit__()`方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。\n\n## 运行时上下文(runtime context)\n\n由上下文管理器创建，通过上下文管理器的 `__enter__() 和__exit__()` 方法实现，`__enter__()` 方法在语句体执行之前进入运行时上下文，`__exit__()` 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。\n\n## 上下文表达式(Context Expression)\n\nwith 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。\n\n## 语句体(with-body)\n\nwith 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 `__enter__()`方法，执行完语句体之后会执行 `__exit__()` 方法。\n\n## contextlib 模块\n\n提供了3个对象：装饰器 contextmanager、函数 nested(可将多个上下文管理器组织在一起，避免嵌套with语句) 和上下文管理器 closing。使用这些对象，可以对已有的生成器函数或者对象进行包装，加入对上下文管理协议的支持，避免了专门编写上下文管理器来支持 with 语句。\n\n使用nested注意：发生异常后，如果某个上下文管理器的 `__exit__()` 方法对异常处理返回 False(向上层抛异常)，则更外层的上下文管理器不会监测到异常。\n\n# 库/框架注意\n\n+ 包和模块的命名采用小写、单数形式，而且短小。\n+ 包通常仅作为命名空间，如只包含空的__init__.py文件。\n\n# 避免劣化代码\n\n+ 避免只用大小写来区分不同的对象。\n+ 避免使用容易引起混淆的名称。\n+ 不要害怕过长的变量名。\n\n# 编写pythonic代码\n\n+ 全面掌握python提供的所有特性，包括语言特性和库特性。\n+ 随着python的更新要不断更新python知识。\n+ 深入学习业界公认的比较pythonic的代码，比如Flask、gevent和requests等。\n+ 可以采用PEP8规范检查python是否够pythonic。\n\nC是编译性语言，python是脚本语言，从原理上来说是完全不一样的。一些语法的不同：\n+ 缩进与{}。\n+ 单双引号。\n+ 三元操作符?:。python使用x if condition else y来替代。\n+ switch case。python没有这个，可以使用if...elif...else来替换，也可以使用跳转表实现：def f(x):return {0: 'NOK'，1: 'OK'，2: 'Go'}.get(x，'Default')\n+ 在代码中适当添加注释。\n+ 通过适当添加空行使代码布局更为优雅、合理。\n\n# python语言特性\n\n函数传参：Python中所有的变量都可以理解为内存中一个对象的引用，或者也可以看似C中的void *。这里记住的是类型是属于对象的，而不是变量。对象分为两种：\n+ 可更改的：list，dict\n+ 不可更改的：strings，tuples，numbers\n\n当向函数传递一个参数，即引用的时候：\n+ 如果该参数是函数外一个不可变的对象的引用，则函数执行完之后，在函数外打印的是原来的值，与函数对该引用做什么事情无关。\n+ 如果该函数是函数外一个可变的对象的引用，则函数执行完之后，在函数外打印的是该引用所执行的内存空间改变的结果。\n\n普通方法、实例方法、类方法和静态方法：\n+ 普通方法：在一个Python环境中，独立于类或者对象的函数，可直接导入文件中的方法直接使用。\n+ 实例方法：类中定义，使用之前先通过类实例化一个对象，然后在通过对象调用实例方法。与c++类似。实例方法的第一个参数默认传入一个self，这个self会与实例绑定。\n+ 类方法：与实例方法的调用方式类似，不同的是类方法第一个参数默认传入一个类cls，而不是对象。\n+ 静态方法：对于静态方法其实和普通的方法一样，不需要对谁进行绑定，唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用.\n+ 静态方法修饰：@staticmethod\n+ 类方法修饰：@classmethod\n\n类属性和实例属性：\n+ 类属性就是供类使用的属性，实例属性就是供实例使用的属性。\n+ 由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量\n+ 定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。\n+ 不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当删除实例属性后，再使用相同的名称，访问到的将是类属性。\n\n# Python自省\n\n自省就是面向对象的语言所写的程序在运行时，所能知道对象的类型。简单一句就是运行时能够获得对象的类型。比如type()，dir()，getattr()，hasattr()，isinstance()。\n\n# 推导式（列表推导式、字典推导式、集合推导式）\n\n推导式comprehensions（又称解析式），是Python的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。共有三种推导，在Python2和3中都有支持：\n+ 列表(list)推导式：`[out_exp_res for out_exp in input_list if out_exp == 2]`  将列表推导式的 [] 改成 () 即可得到生成器。\n+ 字典(dict)推导式：`{v: k for k，v in mcase.items()}`\n+ 集合(set)推导式：`{x**2 for x in [1，1，2]}`\n\n# 生成器generator\n\n通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。所以，如果列表元素可以按照某种算法推算出来，这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。\n+ 第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator。如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值，但正确的方法是使用for循环，因为generator也是可迭代对象。\n+ 第二种方法，生成器函数。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n\n# 单下划线和双下划线\n+ `__foo__`：一种约定，Python内部的名字，用来区别其他用户自定义的命名，以防冲突。\n+ `_foo`：一种约定，程序员用来指定私有变量的一种方式。\n+ `__foo`：解析器用_classname__foo来代替这个名字，以区别和其他类相同的命名。\n\n# 字符串格式化\n\n%和format函数格式化的用法。format在许多方面看起来更便利，对于%最烦人的是它无法同时传递一个变量和元组。\n\n# `*args and **kwargs(可变参数)`\n\n用`*args和**kwargs`只是为了方便并没有强制使用它们。当不确定你的函数里将要传递多少参数时可以用*args(其是可迭代对象)；**kwargs是字典。\n\n# 变量解包\n+ `*` - 可以解包可迭代对象。foo(*iter)\n+ `**` - 可以解包字典。foo(**dict)\n\n# 编写函数的4个原则\n+ 函数的设计要尽量短小，嵌套层次不宜过深。\n+ 函数名能够正确反映它的大概作用，参数的设计也应该简单明了。\n+ 函数的设计应该考虑向下兼容。\n+ 一个函数只做一件事，尽量保证函数语句粒度的一致性。\n\npython是动态语言，支持的常量很少很少，只有简单的True、False、None等。\n+ 通过命名风格来提醒使用者该变量代表的意义为常量，如全部大写。\n+ 通过自定义类来实现常量功能。\n\n# assert断言\n\n断言是有代价的，它会对性能产生一定的影响。对于编译性语言，像C/C++，这也许并不重要，因为断言只在调试模式下生效。但python并没有严格的调试和发布模式，通常禁用断言的方法是在运行脚本的时候加上-O标识，这种方式影响是它并不优化字节码，而是忽略与断言相关的语句。assert断言实际被设计用来捕获用户所定义的约束的，而不是用来捕获程序本身错误的，因此使用断言需要注意以下几点：\n+ 不要滥用，这是断言最基本的原则。若由断言引发了异常，通常代表程序中存在bug。因此断言应该用在正常逻辑不可到达的地方或正常情况下总是为真的场合。\n+ 如果python本身异常能够处理就不要使用断言，如数组越界、类型不匹配、除数为0之类的错误。\n+ 不要使用断言来检查用户的输入。\n+ 在函数调用后，当需要确认返回值是否合理时可以使用断言。\n+ 当条件是业务逻辑继续下去的先决条件时可以使用断言。\n\n# 数据交换的时候不推荐使用中间变量\n```python\ndef func_10():\n    # 斐波拉契数列，生成器函数，按需索取\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n```\n\n# 充分利用Lazy evaluation的特性(生成器，延迟计算)：\n\n列表推导式：lis = [x/2 for x in range(5000000)]\n\n生成器（延迟计算）：gen = (x/2 for x in range(5000000))\n\n# 生成器函数\n```python\ndef divby2(n):\n    num = 0\n    while num < n:\n        yield num/2\n        num += 1\n```\n注意：小心yield的无限循环。\n\n基本上，一个生成器允许返回一个类似列表的结构，但这里有一些区别：\n+ 列表存储创建时的所有元素。而生成器在需要时生成下一个元素。\n+ 列表可以无限次遍历，而生成器只能尽可能准确地迭代一次。\n+ 一个列表可以通过索引获取元素，而生成器不能，它从头到尾只产生一次值。\n\n# and和or的截断\n\n+ x and y：如果x为假，那么表达式就为假，不再计算y。\n+ x or y：如果x为真，那么表达式就为真，不再计算y。\n\n# 判断类型\n\n不推荐使用type来进行类型检查，并不能准确地返回结果。推荐使用isinstance函数。\n\n# 浮点计算\n\n尽量转换成浮点类型后再做除法，对于浮点数的处理，其计算结果并不是完全准确的。如果计算精度要求较高，可以使用Decimal来进行处理或者将浮点数尽量扩大为整数，计算完毕后再转换回去。\n\n**警惕eval()的安全漏洞(执行任意代码)**，其可以将字符串str当成有效的表达式来求值并返回计算结果。其和exec差不多，一般用于动态调用。\n\n# enumerate()\n\n使用enumerate()获取序列迭代的索引值。\n\n# 分清==与is的适用场景\n\nPython中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。is和==都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。\n+ ==比较操作符(比较判断两个对象的value(值)是否相等)\n+ is同一性运算符(比较判断的是对象间的唯一身份标识，也就是id是否相同)\n\n==实际上是调用的__eq__()方法，因此a==b实际是调用的a.__eq__(b)，所以==可以被重载，但是is不行。一般情况下，如果x is y是True，那么x == y也是True(特殊情况除外，如NaN; a=float('NaN'), 虽然a is a为True，但a == a为False)，反之则不然。\n\n# 考虑兼容性\n\n尽可能使用unicode。在python3中，统一为了unicode，只有byte和string两种类型。\n\n# 构建合理的包层次来管理module\n\n在包目录下有一个`__init__.py`文件，一般这个文件为空。可以在该文件中申明模块级别的import语句，从而使其变成包级别可见。`__init__.py`文件还有一个作用就是通过在该文件中定义__all__.py变量，控制需要导入的子包或者模块。\n\n# python提供了三种方式来导入外部模块\n\nimport语句、from...import...及__import__函数。__import__函数与import语句类似，不同点在于前者显式地将模块的名称作为字符串传递并赋值给命名空间的变量。在导入模块的时候，尽量遵循以下几点：\n+ 一般情况下优先使用import a形式。\n+ 有节制地使用from a import B形式。\n+ 尽量避免使用from a import *，因为这会污染命名空间，并且无法清晰地表示导入了哪些对象。\n\npython在初始化运行环境的时候会预先加载一批内建模块到内存中，这些模块相关的信息被存放在sys.modules中。当加载一个模块时，解释器实际上要完成以下动作：\n+ 在sys.modules中搜索看看该模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。\n+ 如果在sys.modules中找不到对应模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入sys.modules中。\n+ 加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。\n+ 执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。\n\n注意：直接使用import和使用from a import B形式这两者之间存在一定的差异，后者直接将B暴露于当前局部空间，并将a加载到sys.modules集合。\n\n无节制地使用from a import *会导致一些问题：\n+ 命名空间的冲突\n+ 循环嵌套导入的问题\n\n优先使用absolute import来导入模块，即绝对路径导入。\n\n# i+=1不等于i=i+1\n\n增强赋值语句比普通赋值语句的效率更高，这是因为在 Python 源码中，增强赋值比普通赋值多了写回的功能，也就是说增强赋值在条件符合的情况下会以追加的方式来进行处理，而普通赋值则会以新建的方式进行处理。\n\n# ++1和--1\n\npython不支持后自增(减)操作(1++/1--)，只支持前自增(减)操作，但是python仅仅把它认为是正负号的叠加使用，而不会去真正的进行加减操作。\n\n# 使用with自动关闭资源\n\nwith支持嵌套，支持多个with子句，它们两者之间可以互相转换。with代码块的执行过程如下：\n+ 计算表达式的值，返回一个上下文管理器对象。\n+ 加载上下文管理器对象的__exit__()方法以备后用。\n+ 调用上下文管理器对象的__enter__()方法。\n+ 如果with语句中设置了目标对象，则将__enter__()方法的返回值赋给目标对象。\n+ 执行with中的代码块。\n+ 如果步骤5中的代码正常结束，调用上下文管理器对象的__exit__()方法，其返回值直接忽略。\n+ 如果步骤5中代码执行过程中发生异常，调用上下文管理器对象的__exit__()方法，并将其异常类型、值及traceback信息作为参数传递给__exit__()方法。如果__exit__()返回值为false，则异常被重新抛出；如果为true，异常被挂起，程序继续执行。\n\n# 上下文管理器协议\n\n+ `__enter__()`：进行运行时的上下文，返回其运行时上下文相关的对象，with语句中会将这个返回值绑定到目标对象。\n+ `__exit__(exception_type，exception_value，traceback)`：退出运行时的上下文，定义在块执行(或终止)之后上下文管理器应该做什么。它可以处理异常、清理现场或者处理with块中语句执行完成之后需要处理的动作。\n\n可以直接使用contextlib中的contextmanager作为装饰器来提供一种针对函数级别上的上下文管理机制，可以直接作用于函数/对象上。\n\n# 使用else子句简化循环(异常处理)\n\nelse还可以用在循环中，在for/while中，如果循环没有break跳出语句或者没有正常执行完，那么else子句将会被执行。\n\n# 异常处理的几点基本原则\n\n+ 注意异常的粒度，不推荐在try块中放入过多的代码。\n+ 谨慎使用except语句处理所有的异常，最好能定位具体的异常。\n+ 注意异常捕获的顺序，在合适的层次处理异常。推荐的方法是将继承机构中子类异常在前面的except语句中抛出，而父类异常在后面的except语句中抛出。\n\n另外，如果异常能够在被捕获的位置处理，那么就应该及时处理，不能处理的也应该以合适的方式向上层抛出。遇到异常不论好歹就向上抛出是不明智的。向上层抛出异常的时候需要注意异常丢失的情况，可以使用不带参数的raise来传递。使用更为友好的异常，遵循异常参数规范。给用户看的异常一定要是用户能明白的异常。\n\n# 避免finally中可能发生的陷阱\n\n因为当try块中发生异常的时候，如果在except语句中找不到对应的异常处理，异常将被保存起来。当finally执行完毕的时候，临时保存的异常将会再次被抛出。但是如果finally中产生了新的异常或者执行了break或者return语句，那么临时保存的异常将会丢失，从而导致异常的丢失。\n\n# 深入理解None，正确判断对象是否为空\n\nNone表示空对象，而空值(空字符串\"\"，0，空列表[]，空字典{}，空元组())是Python里一个特殊的值，用None表示。\n\n# __nonzero__()方法\n\n对自身对象进行空值测试，返回0/1或者True/False。如果一个对象没有定义该方法，python取`__len__()`方法调用的结果来进行判断。`__len__()`返回0则表示空。如果一个类中既没有定义__nonzero__()也没有定义__len__()方法，该类的实例用if判断都是True。在python3中移除了__nonzero__()方法，并使用__bool__()替代。\n\n# 连接字符串应优先使用join而不是+\n\n用操作符+连接字符串的时候，由于字符串是不可变对象，其工作原理是这样的：如果要连接S1+S2+...+Sn，执行一次+操作便会在内存中申请一块新的内存，并将上一次操作的结果和本次操作的右操作数复制到新申请的内存中。即当S1+S2的时候会申请一块内存，并将S1、S2复制到该内存中。依此类推，相当于S1被复制了n-1次，S2被复制n-2次...Sn被复制1次(并不完全等同于S1复制n-1次，因为后续复制都是对中间结果的复制)，所以字符串的连接时间约为`s*n^2`，其中s为复制依此字符串的平均时间。而用join()的时候，计算机直接计算需要申请的总内存空间，然后一次性申请那么多并将字符序列中的每一个元素复制到内存中去，所以join操作的时间约为`s*n`。\n\n# 格式化字符串尽量使用format()方式，而不是%\n\nformat的基本语法是：`[[填充符] 对齐方式] [符号] [#] [0][宽度][，][.精确值][转换类型]`\n\n其中填充符可以是除了{、}符号之外的任意符号。\n\n## 对齐方式：\n+ `<`    表示左对齐，大多数对象为默认的对齐方式。\n+ `>`    表示右对齐，数值默认的对齐方式。\n+ `=`    仅对数值型有效，如果有符号的话，在符号后数值前进行填充，如-000029。\n+ `^`    居中对齐，用空格进行填充。\n\n## 符号：\n+ `+`       正数前加+，负数前加-。\n+ `-`       正数前不加符号，负数前加-，为数值的默认形式。\n+ `空格`    正数前加空格，负数前加-。\n\n# 区别对待可变对象和不可变对象\n\npython一切皆对象，每一个对象都有一个唯一的标识符、类型以及值。对象根据其值是否能修改分为可变对象和不可变对象。其中数字、字符串、元组属于不可变对象，字典、列表和数组属于可变对象。\n\n**[]、{}和()**：一致的容器初始化形式。\n\n注意：函数传参既不是传值也不是传引用。正确的叫法应该是叫传对象或传对象引用。函数参数在传递过程中将整个对象传入，对可变对象的修改在函数外部以及内部可见，调用者和被调用者之间共享这个对象。而对于不可变对象，由于并不能被真正被修改，因此，修改往往是通过生成一个新对象然后赋值来实现。\n\n# 警惕默认参数潜在的问题\n\ndef在python中是一个可执行语句，当解释器执行def的时候，默认参数也会被计算。在代码编译成PyCodeObject的时候，就已经创建了对象指针，并且存在该函数的func_default内。 以后在代码运行，调用函数的时候，如果没有指定参数的话，并且修改了参数的值，则每次调用该函数时其参数变量都是代码编译阶段的变量指针所指定的对象(即已改变)。\n\n所以定义默认参数要牢记一点：默认参数必须指向不变对象！可用None这个不变对象来实现。\n\n# 慎用变长参数\n\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。Python允许在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进函数中。可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。\n\n# 关键字参数\n\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。同样可以在字典前加一个**号，把字典元素变成关键字参数传进函数中。注意，函数获得的仅是一份拷贝。\n\n# 命名关键字参数\n\n和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了。命名关键字参数必须传入参数名，这和位置参数不同，如果没有传入参数名，调用将报错。命名关键字参数可以有缺省值(有默认值)，从而简化调用。使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个`*`作为特殊分隔符。如果缺少`*`，Python解释器将无法识别位置参数和命名关键字参数。\n\n# 参数组合\n\n在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n\n# str()和repr()的区别\n\n+ 两者之间的目标不同：str()主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型；而repr()面向的是python解释器，或者说开发人员，其目的是准确性，其返回值表示python解释器内部的含义，常作为编程人员debug用途。\n+ 在解释器中直接输入a时默认调用repr()函数，而print(a)则调用str()函数。\n+ repr()的返回值一般可以用eval()函数来还原对象，通常有如下等式：obj == eval(repr(obj))但它并不是在所有情况下都成立，比如用户重新实现了repr()。\n+ 这两个方法分别调用内建的__str__()和__repr__()方法，一般来说在类中都应该定义__repr__()方法，而__str__()方法则为可选，当可读性比准确性更为重要的时候应该考虑定义__str__()方法。如果类中没有定义__str__()方法，则默认会使用__repr__()方法的结果来返回对象的字符串表示形式。用户返回__repr__()方法的时候最好保证其值可以用eval()方法使对象重新还原。\n\n# 分清classmethod和staticmethod的适用场景\n\n|\\|实例方法|类方法|静态方法|\n|:-|:-|:-|:-|\n|a = A()|a.foo(x)|a.class_foo(x)|a.static_foo(x)|\n|A|不可用|A.class_foo(x)|A.static_foo(x)|\n\n在Python中，静态方法和类方法都是可以通过类对象和类对象实例访问。区别是：类方法的第一个参数是cls，而实例方法的第一个参数是self，表示该类的一个实例。实例方法至少需要一个self参数，代表类对象实例。类方法有类变量cls传入，从而可以用cls做一些相关的处理。并且有子类继承时，调用该类方法时，传入的类变量cls是子类，而非父类。对于类方法，可以通过类来调用，也可以通过类的一个实例来调用。而静态方法则没有，它基本上跟一个全局函数相同。\n\n# staticmethod静态方法\n\n+ 静态方法定义在类中，较之外部函数，能够更加有效地将代码组织起来，从而使相关代码的垂直距离更近，提高代码的维护性。\n+ 如果有一组独立的方法，将其定义在一个模块中，通过模块来访问这些方法也是一个不错的选择。\n+ 经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法。\n\n# classmethod类方法\n\n类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显式提供该参数。在继承时动态地生成了对应类的类变量，这就是classmethod的妙用。\n\n# property属性\n\n一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法。单独使用时其一般用于获取只读属性。\n```python\nclass Goods(object):\n\n    def __init__(self):\n        # 原价\n        self.original_price = 100\n        # 折扣\n        self.discount = 0.8\n\n    @property\n    def price(self):\n        # 实际价格 = 原价 * 折扣\n        new_price = self.original_price * self.discount\n        return new_price\n\n    @price.setter\n    def price(self, value):\n        self.original_price = value\n\n    @price.deleter\n    def price(self):\n        del self.original_price\n\nobj = Goods()\nobj.price         # 获取商品价格\nobj.price = 200   # 修改商品原价\ndel obj.price     # 删除商品原价\n\n# 这种装饰器都是可以使用函数形式的\nclass Foo(object):\n    def get_bar(self):\n        print(\"getter...\")\n        return 'laowang'\n\n    def set_bar(self, value): \n        \"\"\"必须两个参数\"\"\"\n        print(\"setter...\")\n        return 'set value' + value\n\n    def del_bar(self):\n        print(\"deleter...\")\n        return 'laowang'\n\n    BAR = property(get_bar, set_bar, del_bar, \"description...\")\n\nobj = Foo()\nobj.BAR  # 自动调用第一个参数中定义的方法：get_bar\nobj.BAR = \"alex\"  # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入\nFoo.BAR.__doc__  # 自动获取第四个参数中设置的值：description...\ndel obj.BAR  # 自动调用第三个参数中定义的方法：del_bar方法\n```\n","tags":["python"]},{"title":"面向对象编程","url":"/2019/04/15/python3 面向对象编程/","content":"\nPython3从设计之初就已经是一门面向对象的语言。与javascript相似，万物皆对象。\n\n# 类(Class)\n\n用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n\n**类变量**：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n\n**数据成员**：类变量或者实例变量用于处理类及其实例对象的相关的数据。\n\n**方法重写**：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖(override)，也称为方法的重写。\n\n**实例变量**：定义在方法中的变量，只作用于类的当前实例。\n\n**继承**：即一个派生类(derived class)继承基类(base class)的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个(is-a)\"关系(例图，Dog是一个Animal)。\n\n**实例化**：创建一个类的实例，类的具体对象。\n\n**方法**：类中定义的函数。\n\n**对象**：通过类定义的数据结构实例。对象包括两个数据成员(类变量和实例变量)和方法。\n\nPython中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。对象可以包含任意数量和类型的数据。\n\n类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。类对象创建后，类命名空间中所有的命名都是有效属性名。\n\n**类对象**：类对象支持两种操作：属性引用和实例化。\n\n# 类定义语法\n```python\nclass ClassName:\n    <statement-1>\n    ...\n    <statement-N>\n```\n\n很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 __init__() 的特殊方法(构造方法)。类定义了 __init__() 方法的话，类的实例化操作会自动调用 __init__() 方法。当然，__init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。\n\nself代表类的实例，而非类(cls)：类的方法与普通的函数只有一个特别的区别，它们必须有一个额外的第一个参数名称，按照惯例它的名称是 self。self 不是 python 关键字，把他换成 this 也是可以正常执行的。\n\n**类的方法定义**：在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。\n\n# 下划线\n\n## 1.单前导下划线 _xxx\n\n变量前面使用单下划线，用于指定该名称为“私有”。为方便自己或者阅读代码的人知道以 _ 开头的名称只供内部使用，也就是说，`from xxx import *`，此时以 _ 开头的名称都不会被导入，除非模块或包中的 __all__ 列表显示的包含了它。\n\n注意：在python中_xxx仅仅是一个约定，其是可以访问的\n\n## 2.单末尾下划线 xxx_\n\n按照PEP8规定，单末尾下划线也是一个约定，用来避免与python关键字产生命名冲突。例如想用class来用作变量名称，可class又是pytohn 关键字，此时class_就解决了这个问题。\n\n## 3.双前导下划线__xxx\n\n名称（具体为一个方法名）前双下划线（__）的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，__spam 这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被 _classname__spam 这种形式原文取代，在这里 classname 是去掉前导下划线的当前类名。\n\n__private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时：self.__private_attrs。\n\n## 4、双前导和双末尾下划线 __var__\n\n如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。即由双下划线前缀和后缀包围的变量不会被Python解释器修改。但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。\n\n这些dunder方法通常被称为神奇方法，但Python社区中的许多人都不喜欢这种方法。最好避免在自己的程序中使用以双下划线（dunders）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。\n\n## 5、单下划线 _\n\n通常情况下，会在以下3种场景中使用：\n+ 在解释器中：在这种情况下，“_”代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。\n+ 作为一个名称：这与上面一点稍微有些联系，此时“_”作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。类似于golang的 _ ，忽略。\n+ 国际化：也许你也曾看到“_”会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。\n\n注意：场景二和场景三中的使用方法可能会相互冲突，所以需要避免在使用 _ 作为国际化查找转换功能的代码块中同时使用 _ 作为临时名称。\n\n# 派生类的定义语法\n```python\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    ...\n<statement-N>\n```\n\n需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。BaseClassName(示例中的基类名)必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用：class DerivedClassName(modname.BaseClassName):\n\n# 多继承\n\nPython同样有限的支持多继承形式。多继承的类定义语法：\n```python\nclass DerivedClassName(Base1, Base2, Base3):\n    <statement-1>\n    ...\n<statement-N>\n```\n\n需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索,即方法在子类中未找到时，从左到右查找父类中是否包含方法。\n\n# 运算符重载\n\nPython同样支持运算符重载，可以对类的专有方法进行重载。与他相关的是operator标准库。\n","tags":["python"]},{"title":"函数概念","url":"/2019/03/12/python3 函数/","content":"\n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。\n\n# 定义一个函数\n\n+ 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。\n+ 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。\n+ 函数的第一行语句可以选择性地使用文档字符串,用于存放函数说明。\n+ 函数内容以冒号起始，并且缩进。\n+ `return [表达式]` 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。\n\n# 函数调用\n\n+ 有参数就传入参数，后面加上括号即是调用。\n+ *用于解包序列参数，**用于解包字典参数。\n+ 函数在python中是一等公民，可以当作参数传递。\n\n# 参数传递\n\n在 python 中，类型属于对象，变量是没有类型的，其仅仅是对象的引用(一个指针)。在 python 中，strings，tuples，和 numbers 是不可更改的对象，而 list，dict 等则是可以修改的对象。\n\n## 不可变类型\n\n类似 c++ 的值传递，如整数、字符串、元组。如fun(a)，传递的只是a的值，没有影响a对象本身。比如在 fun(a)内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。\n\n## 可变类型\n\n类似 c++ 的引用传递，如列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后fun外部的la也会受影响。\n\n>python 中一切都是对象，严格意义不能说值传递还是引用传递，应该说传不可变对象和传可变对象。\n\n# 参数\n\n+ 必需参数：必需参数须以正确的顺序传入函数，调用时的数量必须和声明时的一样。\n+ 关键字参数：函数调用使用关键字参数来确定传入的参数值，参数顺序和声明可以不同。\n+ 默认参数：调用函数时，如果没有传递参数，则会使用默认参数。\n+ 不定长参数：星号(*)的变量名会存放所有未命名的变量参数。\n\n# 匿名函数\n\npython 使用 lambda 来创建匿名函数。所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。有以下特性：\n+ lambda 只是一个表达式，函数体比 def 简单很多。\n+ lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。\n+ lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。\n+ 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n+ lambda 函数的语法只包含一个语句：lambda [arg1 [，arg2，.....argn]]:expression\n\n# return语句\n\n`return [表达式]` 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。\n\n# 变量作用域\n\n变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：\n+ L (Local) 局部作用域\n+ E (Enclosing) 闭包函数外的函数中\n+ G (Global) 全局作用域：g_count = 0\n+ B (Built-in) 内建作用域：x = int(2.9)\n\n以 L -> E -> G ->B 的规则查找，即：在局部找不到，便会去局部外的局部找(例如闭包)，再找不到就会去全局找，再者去内建中找。\n\n**注意**：只有模块(module)，类(class)以及函数(def、lambda)才会引入新的作用域，其它的代码块(如 if/elif/else/、try/except、for/while等)是不会引入新的作用域的，也就是说这这些语句内定义的变量，外部也可以访问。\n\n# 全局变量和局部变量\n\n定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到局部作用域中。\n\n# global 和 nonlocal关键字\n\n当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字。如果要修改嵌套作用域(enclosing 作用域，外层非全局作用域)中的变量则需要 nonlocal 关键字(比如闭包中)。\n","tags":["python"]},{"title":"流程控制语句","url":"/2019/02/16/python3 流程控制语句/","content":"\n## 条件控制语句\n\n关键字if - elif - else。\n\n+ 每个条件后面要使用冒号(:)，表示接下来是满足条件后要执行的语句块。\n+ 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。\n+ 在Python中没有switch - case语句。\n\n## 循环控制语句\n\n循环语句有 for 和 while，没有do..while循环。\n\n可以使用 CTRL+C 来退出当前的无限循环，无限循环在服务器上客户端的实时请求非常有用。\n\nwhile 循环可以使用 else 语句：在条件语句为 false 时执行 else 的语句块。类似if语句语法，如果while循环体中只有一条语句，可以将该语句与while写在同一行中。\n\n### for 语句\n\nfor循环可以遍历任何序列的项目，如一个列表或者一个字符串。也可使用 else 语句：在条件语句为 false 时执行 else 的语句块。\n\nbreak 语句用于跳出当前循环体，之后剩余语句不执行，任何else块将不执行；continue语句用于跳出当次循环块后的语句，进入下一轮循环。\n\n需要遍历数字序列，可以使用内置range()函数。它会生成数列。也可以使用range指定区间的值。也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做步长)。\n\n## pass 语句\n\npass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。\n","tags":["python"]},{"title":"基本类型相关","url":"/2019/02/15/python3 基本类型相关/","content":"\n## 列表和元组\n\n|语句|函数|\n|:-|:-|\n|len(list)|列表元素个数|\n|max(list)|返回列表元素最大值|\n|min(list)|返回列表元素最小值|\n|list(seq)|将元组转换为列表|\n\n## 列表方法\n\n|语句|方法|\n|:-|:-|\n|list.append(obj)|在列表末尾添加新的对象|\n|list.count(obj)|统计某个元素在列表中出现的次数|\n|list.extend(seq)|在列表末尾一次性追加另一个序列中的多个值(用新列表扩展原来的列表)|\n|list.index(obj)|从列表中找出某个值第一个匹配项的索引位置|\n|list.insert(index，obj)|将对象插入列表|\n|`list.pop(obj=list[-1])`|移除列表中的一个元素(默认最后一个元素)，并且返回该元素的值|\n|list.remove(obj)|移除列表中某个值的第一个匹配项|\n|list.reverse()|反向列表中元素|\n|`list.sort([func])`|对原列表进行排序|\n|list.clear()|清空列表|\n|list.copy()|复制列表|\n\n## 字典键的特性\n\n字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。两个重要的点需要记住：\n+ 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。\n+ 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行。\n","tags":["python"]},{"title":"字符串常见操作","url":"/2019/02/15/python3 字符串常见操作/","content":"\n字符串是最常用的数据类型。可以使用引号('或\")来创建字符串。\n\n# 字符串运算符\n\n|操作符|描述|\n|:-|:-|\n|+|字符串连接|\n|*|重复输出字符串|\n|[]|通过索引获取字符串中字符|\n|[ : ]|截取字符串中的一部分|\n|in|成员运算符 - 如果字符串中包含给定的字符返回 True|\n|not in|成员运算符 - 如果字符串中不包含给定的字符返回 True|\n|r/R|原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母\"r\"(可以大小写)以外，与普通字符串有着几乎完全相同的语法。|\n|%|格式字符串|\n\n# 字符串格式化\n\nPython 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。这是C语言的字符串格式化写法，python3不推荐这样写，推荐使用format()函数。  \nformat()函数标准格式说明符的一般形式如下：   \nformat_spec := `[[fill]align][sign][#][0][width]|[grouping_option][.precision][type]`  \nfill := `<any character>`  \nalign := `\"<\" | \">\" | \"=\" | \"^\"`  \nsign := `\"+\" | \"-\" | \" \"`  \nwidth := digit+  \ngrouping_option := `\"_\" | \",\"`  \nprecision := digit+  \ntype := `\"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\"`\n\n## 示例\n\n```python\n# 按位置访问序列参数\n'{},{},{}'.format('a', 'b', 'c')\n'{0},{1},{2}'.format('a', 'b', 'c')\n'{2},{1},{2}'.format('a', 'b', 'c')\n\n# 按名称访问字典参数\ncoord = {'latitude': '37.24N', 'longitude': '-115.81W'}\n'Coordinates: {latitude}, {longitude}'.format(**coord)  # **解包字典\n\n# 访问对象参数的属性\nclass Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n\n    def __str__(self):\n        return 'Point({self.x}, {self.y})'.format(self=self)\n\n# 访问序列参数的项\n'X: {0[0]};  Y: {0[1]}'.format([3, 5])\n\n# 替代 %s 和 %r\n\"repr() shows quotes: {!r}; str() doesn't: {!s}\".format('test1', 'test2')\n\n# 对齐文本以及指定宽度\n'{:<30}'.format('左对齐')\n'{:>30}'.format('右对齐')\n'{:^30}'.format('居中')\n'{:*^30}'.format('centered')  # 使用 '*' 作为填充字符\n\n# 替代 %+f, %-f 和 % f 以及指定正负号\n'{:+f}; {:+f}'.format(3.14, -3.14)  # 总是显示正负号\n'{: f}; {: f}'.format(3.14, -3.14)  # 正号用空格替代\n'{:-f}; {:-f}'.format(3.14, -3.14)  # 与{:f}相同，仅显示负号\n\n# 替代 %x 和 %o 以及转换基于不同进位制的值\n\"int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}\".format(42)\n\"int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}\".format(42)\n\n# 使用逗号作为千位分隔符\n'{:,}'.format(1234567890)\n\n# 表示为百分数\n'Correct answers: {:.2%}'.format(0.26449781)\n\n# 使用特定类型的专属格式化\nimport datetime\nd = datetime.datetime(2010, 7, 4, 12, 15, 58)\n'{:%Y-%m-%d %H:%M:%S}'.format(d)\n```\n\n# python三引号\n\npython三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。\n","tags":["python"]},{"title":"数字(Number)相关函数","url":"/2019/02/10/python3 数字(Number)相关函数/","content":"\nPython 数字数据类型用于存储数值。数据类型是不允许改变的，这就意味着如果改变数字数据类型得值，将重新分配内存空间。\n\n## math数学函数\n\n|函数|返回值(描述)|\n|:-|:-|\n|abs(x)|返回数字的绝对值，如abs(-10) 返回 10|\n|ceil(x)|返回数字的上入整数，如math.ceil(4.1) 返回 5|\n|cmp(x，y)|如果 x < y 返回 -1，如果 x == y 返回 0，如果 x > y 返回 1。Python 3 已废弃,使用 `(x>y)-(x<y) 替换`|\n|exp(x)|返回e的x次幂，如math.exp(1) 返回2.718281828459045|\n|fabs(x)|返回数字的绝对值，如math.fabs(-10) 返回10.0|\n|floor(x)|返回数字的下舍整数，如math.floor(4.9)返回 4|\n|log(x)|返回对数，如math.log(math.e)返回1.0，math.log(100，10)返回2.0|\n|log10(x)|返回以10为基数的x的对数，如math.log10(100)返回 2.0|\n|max(x1，x2，...)|返回给定参数的最大值，参数可以为序列。|\n|min(x1，x2，...)|返回给定参数的最小值，参数可以为序列。|\n|modf(x)|返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。|\n|pow(x，y)|x**y 运算后的值。|\n|`round(x [,n])`|返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。|\n|sqrt(x)|返回数字x的平方根，数字可以为负数，返回类型为实数，如math.sqrt(4)返回 2+0j|\n\n## random随机数函数\n\n|函数|描述|\n|:-|:-|\n|choice(seq)|从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数|\n|`randrange([start,] stop[,step])`|从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1|\n|random()|随机生成下一个实数，它在[0，1)范围内|\n|`seed([x])`|改变随机数生成器的种子seed。如果不了解其原理，不必特别去设定seed，Python会选择seed|\n|shuffle(lst)|将序列的所有元素随机排序|\n|uniform(x，y)|随机生成下一个实数，它在`[x，y]`范围内|\n\n## 三角函数\n\n|函数|描述|\n|:-|:-|\n|acos(x)|返回x的反余弦弧度值|\n|asin(x)|返回x的反正弦弧度值|\n|atan(x)|返回x的反正切弧度值|\n|atan2(y，x)|返回给定的 X 及 Y 坐标值的反正切值|\n|cos(x)|返回x的弧度的余弦值|\n|hypot(x，y)|返回欧几里德范数 `sqrt(x*x + y*y)`|\n|sin(x)|返回的x弧度的正弦值|\n|tan(x)|返回x弧度的正切值|\n|degrees(x)|将弧度转换为角度，如degrees(math.pi/2) ，返回90.0|\n|radians(x)|将角度转换为弧度|\n\n## 数学常量\n\n|常量|描述|\n|:-|:-|\n|pi|数学常量 pi(圆周率，一般以π来表示)|\n|e|数学常量 e，e即自然常数|\n\n## 数值类型转换\n\n|表达式|描述|\n|:-|:-|\n|int(x [,base])|将x（其他进制）转为十进制整数|\n|float(x)|将x转为浮点数|\n|compile(x)|创建复数|\n|str(x)|将对象x转为字符串|\n|repr(x)|将对象x转为表达式字符串|\n|eval(str)|执行python字符串表达式，并返回对象|\n|tiple(s)|将序列s转为元组|\n|list(s)|将序列s转为列表|\n|chr(x)|将unicode码(整数)转为字符|\n|ord(x)|将字转为符unicode码(整数)|\n|hex(x)|将整数转为十六进制字符串|\n|oct(x)|将整数转为八进制字符|\n","tags":["python"]},{"title":"数值计算","url":"/2019/02/08/python3 数值计算/","content":"\nPython3 数值计算包括：操作数和操作符\n\n## Python算术运算符\n\n|运算符|描述|实例|\n|:-|:-|:-|\n|+|加 - 两个对象相加|a + b 输出结果 31|\n|-|减 - 得到负数或是一个数减去另一个数|a - b 输出结果 -11|\n|*|乘 - 两个数相乘或是返回一个被重复若干次的字符串|a * b 输出结果 210|\n|/|除 - x 除以 y|b / a 输出结果 2.1|\n|%|取模 - 返回除法的余数|b % a 输出结果 1|\n|`**`|幂 - 返回x的y次幂|a`**`b 为10的21次方|\n|//|取整除 - 返回商的整数部分|9//2 输出结果 4 ，9.0//2.0 输出结果 4.0|\n\n## Python赋值运算符\n\n|运算符|描述|实例|\n|:-|:-|:-|\n|=|简单的赋值运算符|c = a + b 将 a + b 的运算结果赋值为 c|\n|+=|加法赋值运算符|c += a 等效于 c = c + a|\n|-=|减法赋值运算符|c -= a 等效于 c = c - a|\n|*=|乘法赋值运算符|c *= a 等效于 c = c * a|\n|/=|除法赋值运算符|c /= a 等效于 c = c / a|\n|%=|取模赋值运算符|c %= a 等效于 c = c % a|\n|`**=`|幂赋值运算符|`c **= a 等效于 c = c ** a`|\n|//=|取整除赋值运算符|c //= a 等效于 c = c // a|\n\n## Python位运算符\n\n按位运算符是把数字看作二进制来进行计算的。\n\n|运算符|描述|实例|\n|:-|:-|:-|\n|&|按位与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0|(a & b) 输出结果 12 ，二进制解释： 0000 1100|\n|`|`|按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。|`(a | b) 输出结果 61 ，二进制解释： 0011 1101`|\n|^|按位异或运算符：当两对应的二进位相异时，结果为1|(a ^ b) 输出结果 49 ，二进制解释： 0011 0001|\n|~|按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1|(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。|\n|<<|左移动运算符：运算数的各二进位全部左移若干位，由\"<<\"右边的数指定移动的位数，高位丢弃，低位补0。|a << 2 输出结果 240 ，二进制解释： 1111 0000|\n|>>|右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数|a >> 2 输出结果 15 ，二进制解释： 0000 1111|\n\n## Python逻辑运算符\n\n|运算符|逻辑表达式|描述|\n|:-|:-|:-|\n|and|x and y|布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。|\n|or|x or y|布尔\"或\" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。|\n|not|not x|布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。|\n\n## Python成员运算符\n\n除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。\n\n|运算符|描述|实例|\n|:-|:-|:-|\n|in|如果在指定的序列中找到值返回 True，否则返回 False|x 在 y 序列中 ，如果 x 在 y 序列中返回 True|\n|not in|如果在指定的序列中没有找到值返回 True，否则返回 False|x 不在 y 序列中 ，如果 x 不在 y 序列中返回 True|\n\n## Python身份运算符\n\n身份运算符用于比较两个对象的存储单元\n\n|运算符|描述|实例|\n|:-|:-|:-|\n|is|is 是判断两个标识符是不是引用自一个对象|x is y，类似 id(x) == id(y) ，如果引用的是同一个对象则返回 True，否则返回 False|\n|is not|is not 是判断两个标识符是不是引用自不同对象|x is not y ，类似 id(a) != id(b)，如果引用的不是同一个对象则返回结果 True，否则返回 False|\n\n注：id() 函数用于获取对象的内存地址。\n\n**is 与 == 区别**：is 用于判断两个变量引用对象内存地址是否为同一个，== 用于判断引用变量的值是否相等。\n\n## Python运算符优先级\n\n优先级不用记，直接括号强制优先。  \n注意：数字 0 是假，其他都是真；字符 \"\" 是假，其他都是真。\n","tags":["python"]},{"title":"基本数据类型","url":"/2019/02/07/python3 数据类型/","content":"\nPython 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在 Python 中，变量就是变量，它没有类型，所说的\"类型\"是指变量的内存中对象的类型。\n\n注意：等号(=)用来给变量赋值。等于(==)比较运算符是用于比较。\n\n# 多个变量赋值\n\nPython允许同时为多个变量赋值。也可以为多个对象指定多个变量。\n\nPython3 中有六个标准的数据类型：\n+ Number(数字)，支持 int(表示为长整数)、float、bool、complex(复数)\n+ String(字符串)\n+ List(列表)\n+ Tuple(元组)\n+ Sets(集合)\n+ Dictionary(字典)\n\n注意：内置的 type() 函数可以用来查询变量所指的对象类型。也可以用 isinstance 来判断，返回布尔值，如isinstance(x，int)，类似于断言。\n\n注：del语句可以删除一些对象引用，也可以通过使用del语句删除单个或多个对象。\n\n## 数值运算\n\n+ Python可以同时为多个变量赋值，如a，b = 1，2。\n+ 一个变量可以通过赋值指向不同类型的对象。\n+ 数值的除法(/)总是返回一个浮点数，要获取整数使用//操作符。%取余；**乘方。\n+ 在混合计算时，Python会把整型转换成为浮点数。\n\n## String(字符串)\n\n+ Python中的字符串用单引号(')或双引号(\")括起来。\n+ 字符串的截取的语法格式：`变量[头下标:尾下标]`。\n+ 两种索引方式：索引值以 0 为开始值，-1 为从末尾的开始位置。\n+ 加号 (+) 是字符串的连接符，星号 (*) 表示复制当前字符串，紧跟的数字为次数。\n\n注意：Python 没有单独的字符类型，一个字符就是长度为1的字符串。同时Python 字符串不能被改变。向一个索引位置赋值，比如`word[0] = 'm'`会导致错误。\n\nPython 使用反斜杠(\\)转义特殊字符，如果不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串。另外，反斜杠(\\\\)可以作为续行符，表示下一行是上一行的延续。也可以使用 \"\"\"...\"\"\" 或者 '''...''' 跨越多行。\n\n## List(列表)\n\n列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表(所谓嵌套)。列表是写在方括号([])之间、用逗号分隔开的元素列表。和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。与Python字符串不一样的是，列表中的元素是可以改变的。\n\n## Tuple(元组)\n\n元组(tuple)与列表类似，不同之处在于元组的元素不能修改。元组写在小括号(())里，元素之间用逗号隔开。元组中的元素类型也可以不相同。元组与字符串类似，可以被索引，也可以进行截取。可以把字符串看作一种特殊的元组。虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表(一般不要这么做)。  \n一般来说，函数的返回值为一个，而函数返回多个值的时候，是以元组的方式返回的。而可变长参数是将所有的参数收集到一个元组上，如*args。\n\n构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：\n+ tup1 = ()    # 空元组\n+ tup2 = (20，)  # 一个元素，需要在元素后添加逗号\n\n注意：string、list和tuple都属于sequence(序列)。\n\n## Set(集合)\n\n集合(set)是一个无序不重复元素的序列。基本功能是进行成员关系测试和删除重复元素。可以使用大括号 {} 或者 set() 函数创建集合。\n\n注意：创建一个空集合必须用 set() 而不是 {}，因为 {} 是用来创建一个空字典。\n\n## Dictionary(字典)\n\n字典(dictionary)是Python中的内置数据类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。  \n字典是一种映射类型，它的元素是键值对。字典用{}标识，它是一个无序的键(key):值(value)对集合。  \n键(key)必须使用不可变类型，且在同一个字典中，键(key)必须是唯一的。构造函数 dict() 可以直接从键值对序列中构建字典。另外，字典类型也有一些内置的函数。  \npython中的字典是使用了一个称为散列表(hashtable)的算法，其特点就是：不管字典中有多少项，in操作符花费的时间都差不多。如果把一个字典对象作为for的迭代对象，那么这个操作将会遍历字典的键，而不是值。  \n\n## Python数据类型转换\n\n需要对数据内置的类型进行转换，数据类型的转换，只需要将数据类型作为函数名即可。\n","tags":["python"]},{"title":"python3基础","url":"/2019/02/07/python3 基础/","content":"\n# 标识符\n\n+ 第一个字符必须是字母表中字母或下划线'_'。\n+ 标识符的其他的部分有字母、数字和下划线组成。\n+ 标识符对大小写敏感。\n+ 在Python 3中，非-ASCII 标识符也是允许的了。\n\n# 注释\n\nPython中单行注释以 # 开头；多行注释可以用多个 # 号或是用三引号'''XX'''包含。\n\n# 行与缩进\n\npython最具特色的就是使用缩进来表示代码块，不需要使用大括号({})。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。\n\n# 多行语句\n\nPython 通常是一行写完一条语句，但如果语句很长，可以使用反斜杠(\\\\)来实现多行语句。在 []，{}，或 () 中的多行语句，不需要使用反斜杠(\\\\)。\n\n# 数据类型\n\n## 整数\n\n有四种类型：整数、长整数、浮点数和复数。\n\n## 字符串\n\n+ python中单引号和双引号使用完全相同。\n+ 使用三引号('''或\"\"\")可以指定一个多行字符串。\n+ 转义符 '\\'\n+ 自然字符串，通过在字符串前加r或R，该字符串输出时不会转义。。\n+ 允许处理unicode字符串，加前缀u或U，如 u\"this is an unicode string\"。\n+ 字符串是不可变的。\n+ 按字面意义级联字符串，如\"this \" \"is \" \"string\"会被自动转换为this is string。\n\n# 空行\n\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。\n\n# 等待用户输入\n\nPython提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。注意输入的是字符串。\n\n# 读和写文件\n\nopen() 将会返回一个 file 对象，基本语法格式：f = open(filename，mode)\n+ filename：filename 变量是一个包含了你要访问的文件名称的字符串值。\n+ mode：mode决定了打开文件的模式：只读，写入，追加等。这个参数是非强制的，默认文件访问模式为只读(r)。\n\n打开file文件之后就要关闭文件对象，用f.close。\n\n# 文件对象的方法\n\n+ f.read()：为了读取一个文件的内容，调用 f.read(size)，这将读取一定数目的数据，然后作为字符串或字节对象返回。size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负，那么该文件的所有内容都将被读取并且返回。\n+ f.readline()：会从文件中读取单独的一行。换行符为 '\\n'。f.readline() 如果返回一个空字符串，说明已经已经读取到最后一行。\n+ f.readlines()：将返回该文件中包含的所有行。如果设置可选参数 sizehint，则读取指定长度的字节，并且将这些字节按行分割。另一种方式是迭代一个文件对象然后读取每行。\n+ f.write()：f.write(string) 将 string 写入到文件中，然后返回写入的字符数。\n+ f.tell()：返回文件对象当前所处的位置，它是从文件开头开始算起的字节数。\n+ f.seek()：如果要改变文件当前的位置，可以使用 f.seek(offset，from_what) 函数。from_what 的值，如果是 0 表示开头，如果是 1 表示当前位置，2 表示文件的结尾，例如：seek(x，0) ：从起始位置即文件首行首字符开始移动 x 个字符(默认)；seek(x，1) ：表示从当前位置往后移动x个字符；seek(-x，2)：表示从文件的结尾往前移动x个字符。在文本文件中 (那些打开文件的模式下没有 b 的)，只会相对于文件起始位置进行定位。\n+ f.close()：当你处理完一个文件后，调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。\n\n# 同一行显示多条语句\n\nPython可以在同一行中使用多条语句，语句之间使用分号(;)分割。\n\n# 多个语句构成代码组\n\n缩进相同的一组语句构成一个代码块，称之代码组。像if、while、def和class这样的复合语句，首行以关键字开始，以冒号(:)结束，该行之后的一行或多行代码构成代码组。将首行及后面的代码组称为一个子句(clause)。\n\n# print 输出\n\nprint 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"。即print(x，end=\" \")。\n\n# import 与 from...import\n\npython 用 import 或者 from...import 来导入相应的模块。\n+ 将整个模块(somemodule)导入，格式为： `import somemodule`\n+ 从某个模块中导入某个函数，格式为： `from somemodule import somefunction`\n+ 从某个模块中导入多个函数，格式为： `from somemodule import firstfunc，secondfunc`\n+ 将某个模块中的全部函数导入，格式为： `from somemodule import *`\n\n# 命令行参\n\n很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息。\n\n注意：在 Windows 下可以不写第一行注释，第一行注释的目的是指向 python解释器的路径，告诉操作系统执行这个脚本的时候，调用 /usr/bin 下的 python 解释器。有两种写法：`#!/usr/bin/python3 和 #!/usr/bin/env python3`。\n\n注意：调用 python 的 help() 函数可以打印输出一个函数的文档字符串。如help(max)，按下:q两个按键即退出说明文档(vi)。如果仅仅想得到文档字符串：`print(max.__doc__)`。\n\n# enumerate 函数\n\n使用内置 enumerate 函数进行遍历，可以同步迭代时的序号：\n```python\nfor index,item in enumerate(sequence):\n    process(index,item)\n```\n\n# 迭代器\n\n迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次迭代，而每一次迭代得到的结果会作为下一次迭代的初始值。\n\n迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。\n\n迭代器有两个基本的方法：iter() 和 next()。字符串，列表或元组对象都可用于创建迭代器。\n\n迭代器对象可以使用常规for语句进行遍历，也可以使用 next() 函数。\n\n# 生成器\n\n在 Python 中，使用了yield 的函数被称为生成器(generator)。跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。在调用生成器运行的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。如：\n```python\ndef fibonacci(n):  # 生成器函数 - 斐波那契\n    a，b，counter = 0，1，0\n    while True:\n        if (counter > n): \n            return\n        yield a\n        a，b = b，a + b\n        counter += 1\nf = fibonacci(10)  # f 是一个迭代器，由生成器返回生成\n\nwhile True:\n    try:\n        print (next(f)，end=\" \")\n```\n","tags":["python"]},{"title":"模块解析","url":"/2019/02/03/python3 模块/","content":"\n一个包含所有定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。不管执行了多少次import，一个模块只会被导入一次。\n\n# import模块解析\n\n**import作用**：导入/引入一个python模块，其中包括.py文件、带有__init__.py文件的目录。多次重复使用import语句时，不会重新加载被指定的模块，只是把该模块的内存地址引用到本地变量环境。  \n**reload作用**：对已经加载的模块进行重新加载，一般用于原模块有变化等特殊情况，reload前该模块必须已经import过。reload会重新加载已加载的模块，但原来已经使用的实例还是会使用旧的模块，而新生产的实例会使用新的模块；reload后还是用原来的内存地址；不支持from-import格式的模块进行重新加载。其一般用在sys库的加载。  \n**__import__作用**：同import语句同样的功能，但__import__是一个函数，并且只接收字符串作为参数。其实import语句就是调用这个函数进行导入工作的，`import sys -> sys = __import__('sys')`。通常在动态加载时可以使用到这个函数，比如希望加载某个文件夹下的所用模块，但是其下的模块名称又会经常变化时，就可以使用这个函数动态加载所有模块了，最常见的场景就是插件功能的支持。  \n**通过字符串动态重新加载模块**：reload()无法使用，可以先unimport一个模块，然后再__import__来重新加载模块。通过`del sys.modules['XX']`可以删除一个模块。\n\n使用import语句的时候，Python解释器的搜索路径：搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。类似环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。\n\n# 符号表\n每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以在模块内部使用这些全局变量，而不用担心和其他用户的全局变量混淆。从另一个方面，也可以通过 modname.itemname 这样的表示法来访问模块内的函数。\n\n模块是可以导入其他模块的。在一个模块(或者脚本，或者其他地方)的最前面使用 import 来导入一个模块。当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。\n\n**from … import 语句**：这种导入的方法不会把被导入的模块的名称放在当前的字符表中。\n\n**from … import* 语句**：这将把所有的名字都导入进来，但是那些由单一下划线(_)开头的名字不在此列。大多数情况，不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。\n\n# 其他\n\n**__name__属性**：一个模块被另一个程序第一次引入时，其主程序将运行。如果想在模块被引入时，模块中的某一程序块不执行，可以用__name__属性来使该程序块仅在该模块自身运行时执行。注：每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。\n\n**dir(object) 函数**：内置的函数可以找到模块内定义的所有名称。以一个字符串列表的形式返回，如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称。即返回对象的所有方法。\n\n**标准模块**：Python 本身带着一些标准的模块库。这些组件会根据不同的操作系统进行不同形式的配置。\n\n**包**：是一种管理 Python 模块命名空间的形式，采用点模块名称。比如一个模块的名称是 A.B，那么他表示一个包 A中的子模块 B 。就好像使用模块的时候，不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。\n\n在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字(比如叫做 string)影响搜索路径中的有效模块。最简单的情况，放一个空的文件：__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为 __all__变量赋值。\n\n如果使用形如import item.subitem.subsub.item这种导入形式，import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，那么一个ImportError 异常被抛出。反之，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。\n\n使用 from sound.effects import *会发生什么？Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。\n\n**导入语句遵循如下规则**：如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。\n\n作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了。如果 __all__ 没有定义，那么使用`from sound.effects import *`这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来(可能运行__init__.py里定义的初始化代码)。这会把 __init__.py 里面定义的所有名字导入进来。并且他不会破坏掉在这句话之前导入的所有明确指定的模块。不主张使用*这种方法来导入模块。推荐使用`from Package import specific_submodule`这种方法。无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是\"__main__\"，一个Python应用程序的主模块，应当总是使用绝对路径引用。\n\n包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义。可以修改这个变量，用来影响包含在包里面的模块和子包。这个功能并不常用，一般用来扩展包里面的模块。\n\n**输出格式美化**：Python两种输出值的方式: 表达式语句和 print() 函数。第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。如果希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。如果希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。\n+ str()： 函数返回一个用户易读的表达形式。\n+ repr()： 产生一个解释器易读的表达形式。str() 函数可以转义字符串中的特殊字符，repr()的参数可以是 Python 的任何对象。\n\n字符串对象的 rjust() 方法，它可以将字符串靠右，并在左边填充空格。还有类似的方法，如ljust() 和 center()。 这些方法并不会写任何东西，它们仅仅返回新的字符串。另一个方法 zfill()，它会在数字的左边填充 0。\n\n**旧式字符串格式化**：% 操作符也可以实现字符串格式化。它将左边的参数作为类似 printf() 式的格式化字符串，而将右边的代入，然后返回格式化后的字符串。\n","tags":["python"]},{"title":"hexo初始化博客并部署到github","url":"/2019/01/07/hexo初始化博客并部署到github/","content":"\n# 一、工具准备\n\n* 安装 [Node.js](https://nodejs.org/zh-cn/)\n* 安装 [Git](https://git-scm.com/)\n\n# 二、安装hexo\n\n## 1.全局安装hexo博客\n\n找个地方，新建文件夹；然后在该新文件夹下打开终端，全局安装hexo：\n```cmd\nnpm install -g hexo-cli\n```\n查看版本，检验是否安装成功:\n```cmd\nhexo -v\n```\n\n## 2.生成hexo博客文件\n\n初始化hexo：\n```cmd\nhexo init\n```\n\n## 3.浏览器中预览页面\n\n初始化打开本地服务，浏览器查看默认的hexo页面：\n```cmd\nhexo server\nhexo s  // 其是上面命令的简写\n```\n其默认的地址在：`http://localhost:4000`\n\n# 三、部署到github\n\n## 1.在github建立一个Repositories仓库\n\n生成的Repositories如：https://github.com/BenRmy/benrmy.github.io  \n其中benrmy.github.io就是博客地址\n>注意：仓库名一定要是你github的名字\n\n## 2.安装部署需要的插件\n\n```cmd\nnpm install hexo-deployer-git --save\n```\n\n## 3.修改_config.yml文件\n\n_config.yml文件在项目下打开，修改最后几行：\n```yaml\ndeploy:\n  type: git\n  repo: https://github.com/BenRmy/benrmy.github.io.git\n  branch: master\n```\n>注意：上面需要自定义修改\n\n## 4.开始部署\n\n```cmd\nhexo clean  // 清除缓存\nhexo g  // 上传到仓库\nhexo d  // 部署\n```\n>注意：可能需要你输入github的账号和密码；可以设置ssh秘钥，之后就不会要求输入账号密码了\n\n## 5.在浏览器中输入`benrmy.github.io`，就可以看到博客啦\n\n# 四、其他\n\n不想使用hexo默认的主题，可以修改主题：\n1. 在官网挑选一个主题 \n2. 然后在github下载或clone该主题项目\n3. 放到项目的themes文件夹下\n4. 修改_config.yml设置主题以及安装相关的依赖等\n5. 修改_config.yml文件，将theme:后的主题名修改为刚才下载的主题\n>注意：主题名就是下载的主题的文件夹名，可能需要修改\n\n# 五、写博客\n\n部署好后就可以开始写博客了：\n1. 命令行方式：在项目下输入`hexo new post_title`\n2. 手动添加方式：在`\\source\\_posts`目录下创建md文件\n\n编辑md文件，写好后：\n```cmd\nhexo g // hexo generate 生成静态文件\nhexo s // hexo server 本地查看效果\nhexo d // hexo deploy 部署/发布博客\n```\n","tags":["hexo"]},{"title":"Hello World","url":"/2019/01/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]